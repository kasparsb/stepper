(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.webit || (g.webit = {})).stepper = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var b = function(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    var cx = 3.0 * p1x;
    var bx = 3.0 * (p2x - p1x) - cx;
    var ax = 1.0 - cx -bx;
         
    var cy = 3.0 * p1y;
    var by = 3.0 * (p2y - p1y) - cy;
    var ay = 1.0 - cy - by;

    var epsilon = 0.00001;

    function sampleCurveDerivativeX(t) {
        return (3.0 * ax * t + 2.0 * bx) * t + cx;
    }

    function sampleCurveX(t) {
        // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
        return ((ax * t + bx) * t + cx) * t;
    }

    function sampleCurveY(t) {
        return ((ay * t + by) * t + cy) * t;
    }

    // Given an x value, find a parametric value it came from.
    function solveCurveX(x)
    {
        var t0, t1, t2, x2, d2, i;

        // First try a few iterations of Newton's method -- normally very fast.
        for (t2 = x, i = 0; i < 8; i++) {
            x2 = sampleCurveX(t2) - x;
            if (Math.abs(x2) < epsilon) {
                return t2;
            }
            d2 = sampleCurveDerivativeX(t2);
            if (Math.abs(d2) < 1e-6) {
                break;
            }
            t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
        t1 = 1.0;
        t2 = x;

        if (t2 < t0) {
            return t0;
        }
        if (t2 > t1) {
            return t1;
        }

        while (t0 < t1) {
            x2 = sampleCurveX(t2);
            if (Math.abs(x2 - x) < epsilon) {
                return t2;
            }
            if (x > x2) {
                t0 = t2;
            }
            else {
                t1 = t2;
            }
            t2 = (t1 - t0) * .5 + t0;
        }

        // Failure.
        return t2;
    }

    this.get = function(x) {
        return sampleCurveY(solveCurveX(x));
    }
}

module.exports = b;
},{}],2:[function(require,module,exports){
//var Bezier = require('./bezier1.js');
/**
 * See https://easings.net
 */
var Bezier = require('./bezier2.js');

var Stepper = function(config) {
    this.defaultBezierCurve = [0,0,1,1];
    this.precision = 10000000;
    this.progress = 0;
    this.current = 0;
    this.requestId = 0;
    this.inProgress = false;

    this.config = config;

    this.setConfig();
}

Stepper.prototype = {
    setConfig: function(overrideConfig) {
        this.duration = this.getConfig('duration', overrideConfig);
        this.easing = this.getConfig('bezierCurve', overrideConfig);
        this.stepCallback = this.getConfig('onStep', overrideConfig);
        this.doneCallback = this.getConfig('onDone', overrideConfig);
        this.forceStopCallback = this.getConfig('onForceStop', overrideConfig);
    },

    run: function(overrideConfig) {
        this.setConfig(overrideConfig);

        this.current = 0;

        this.start();
        this.step();
    },

    /**
     * Run from given progress
     */
    runFrom: function(progress, overrideConfig) {
        this.setConfig(overrideConfig);

        /**
         * Šeit ir svarīgs moments
         * Padotais progress ir tāds, kādu gribam
         * bet easing aprēķinātais progress esošajā progress ir savādāk, jo 
         * tas ir curve un tas nav lineārs
         * Tāpēc šeit atrodam kādam ir jābūt progresam pēc easing
         *
         * Update pēc kāda laika lietošanas
         * Tomēr škiet, ka to nemaz nevajag darīt, jo ja es gribu sākt no
         * 0.9 progresa un duration ir 1000ms, tad es gribu, lai animācija
         * ir 100ms gara. Ja pārrēķina progresu, tad animācijas garums ir 
         * garāks vai īsāks
         */
        //progress = this.findStartProgress(progress, 0.1, 0, 1);
        
        this.startTime = +new Date();
        // Simulējam startTime, tā lai tas būtu sācies pirms norādītā progress
        this.startTime -= (this.duration * progress);
        // Turpinām no padotā progress
        this.progress = progress;

        this.inProgress = true;

        this.step();
    },

    /**
     * Meklējam kādam ir jābūt progress, lai pēc easing.get tas būt tāds pats kā progress
     */
    // findStartProgress: function(progress, step, from, to, inceptionLevel) {

    //     if (typeof inceptionLevel == 'undefined') {
    //         inceptionLevel = 0;
    //     }
        
    //     var d = from, prevR = 0, prevD;

    //     while (d < to) {
    //         // Lai ir lielāka precizitāte
    //         if (inceptionLevel++ > 100) {
    //             return d;
    //         }

    //         r = this.easing.get(d);

    //         if (Math.round(progress*this.precision) == Math.round(r*this.precision)) {
    //             return d;
    //         }

    //         if (this.isBetween(progress, prevR, r)) {
    //             return this.findStartProgress(progress, step/10, prevD, d, inceptionLevel);
    //         }

    //         prevD = d;
    //         prevR = r;
    //         d += step;
    //     }

    //     return d;
    // },

    /**
     * Is a between x1 and x2
     */
    // isBetween: function(a, x1, x2) {
    //     if (x2 > x1) {
    //         return a > x1 && a < x2;
    //     }
    //     return a > x2 && a < x1;
    // },

    isRunning: function() {
        return this.inProgress;
    },

    /**
     * Piefiksējam sākuma laiku
     */
    start: function() {
        this.inProgress = true;
        this.startTime = +new Date();
        this.progress = 0;
    },

    /**
     * Pārtraucam stepping
     */
    stop: function() {
        cancelAnimationFrame(this.requestId);
        this.done();
    },

    /**
     * Pārtraucam animāciju un neizpildām done callback
     */
    forceStop: function() {
        cancelAnimationFrame(this.requestId);
        this.inProgress = false;
        if (this.forceStopCallback) {
            this.forceStopCallback();
        }
    },

    done: function() {
        this.inProgress = false;
        if (this.doneCallback) {
            this.doneCallback();
        }
    },

    step: function() {
        var mthis = this;

        mthis.trackProgress();

        if (this.current < this.startTime + this.duration) {

            this.stepCallback(this.progress);

            this.requestId = requestAnimationFrame(function(){
                mthis.step()
            });
        }
        else {
            this.stepCallback(1);

            this.done();
        }
    },

    trackProgress: function() {
        // Current time
        this.current = +new Date();

        var delta = this.current - this.startTime;

        // Animation progress in precents
        this.progress = this.easing.get(delta / this.duration);

        //this.progress = Math.round(this.progress*this.precision)/this.precision;
    },

    getEasing: function(bezierCurve) {
        if (!(bezierCurve && bezierCurve.length && bezierCurve.length == 4)) {
            bezierCurve = this.defaultBezierCurve;
        }
        return new Bezier(bezierCurve[0], bezierCurve[1], bezierCurve[2], bezierCurve[3]);
    },

    /**
     * Atgriežam config vērtību.
     * Katrai vērtībai pēc tās name tiek veiktas pārbaudes vai papildus apstrāde
     * @param secondaryConfig object Alternate override config vērtības
     */
    getConfig: function(name, secondaryConfig) {
        var r = this.getConfigValue(name, secondaryConfig);
        switch (name) {
            case 'bezierCurve':
                r = this.getEasing(r);
                break;
            case 'duration':
                r = parseInt(r, 10);
                r = isNaN(r) ? 200 : r;
                break;
            case 'onStep':
            case 'onDone':
            case 'onForceStop':
                r = typeof r == 'function' ? r : function(){}
        }
        
        return r;
    },

    getConfigValue: function(name, secondaryConfig) {
        // Pirmo meklējam sekundārajā konfigā
        if (secondaryConfig && typeof secondaryConfig[name] != 'undefined') {
            return secondaryConfig[name];
        }

        // Meklējam bāzes konfigā
        if (this.config && typeof this.config[name] != 'undefined') {
            return this.config[name];
        }

        return undefined;
    }
}

module.exports = Stepper;
},{"./bezier2.js":1}]},{},[2])(2)
});
